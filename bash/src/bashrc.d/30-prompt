# -*- mode: shell-script -*-


csi=$'\e['

declare -A __ps1_color=(
    ["black"]="0;30"
    ["red"]="0;31"
    ["green"]="0;32"
    ["yellow"]="0;33"
    ["blue"]="0;34"
    ["pink"]="0;35"
    ["cyan"]="0;36"
    ["white"]="0;37"
    ["gray"]="1;30"
    ["lred"]="1;31"
    ["lgreen"]="1;32"
    ["lyellow"]="1;33"
    ["lblue"]="1;34"
    ["lpink"]="1;35"
    ["lcyan"]="1;36"
    ["lwhite"]="1;37"
)

__ps1_color_1="2;15;15;20"
__ps1_color_2="2;25;25;40"
__ps1_color_3="2;0;0;0"
__ps1_bg_1="48;2;20;20;30"
__ps1_bg_2="48;2;20;20;30"
__ps1_bg_3="48;2;0;0;0"


if [ -f ~/.config/bash/lib/preexec ]; then

    ##
    ## Timestamp the moment the command is entered
    ##

    __ps1_elapsed_start_file="/tmp/bash/$BASH_UUID/ps1_elapsed_start.$$"

    source ~/.config/bash/lib/preexec
    preexec_timestamp_cmd() {
        # echo BASH_COMMAND: $BASH_COMMAND
        # [ "$BASH_COMMAND" == "__fzf_history__" ] && return
        local cols=${COLUMNS:-$(tput cols)}
        local right_part_len=23
        local left_prefix=4
        if [[ "${#BASH_COMMAND}" -gt "$((cols - right_part_len - left_prefix - 1))" ]] &&
               [[ "${#BASH_COMMAND}" -le "$((cols - left_prefix))" ]]; then
            echo
        fi
        printf "\e[s\e[A\e[${cols}C\e[${right_part_len}D${csi}48;${__ps1_color_3};38;${__ps1_color_2}m:${csi}0;30m${csi}48;${__ps1_color_2}m %(%Y-%m-%d %H:%M:%S)T \e[0;30m╮\e[u" -1
        [ -d "${__ps1_elapsed_start_file%/*}" ] ||
            mkdir -p "${__ps1_elapsed_start_file%/*}"
        cat /proc/uptime > "$__ps1_elapsed_start_file"
    }

    ## Add if not already there
    if ! [[ " ${preexec_functions[*]} " == *" preexec_timestamp_cmd "* ]]; then
        preexec_functions+=(preexec_timestamp_cmd)
    fi

    ##
    ## Catch rogue prefix to PS1 and store them in a dedicated place
    ##

    __ps1_new_prefix_file="/tmp/ps1_new_prefix.$$"

    precmd_check_for_PS1_prefix() {
        local prefix
        OLD_COLUMNS="${COLUMNS:-$(tput cols)}"
        if [ "$PS1" != "$ORIGINAL_PS1" ] && [[ "$PS1" == *"$ORIGINAL_PS1" ]]; then
            [ -d "${__ps1_new_prefix_file%/*}" ] ||
                mkdir -p "${__ps1_new_prefix_file%/*}"
            echo -n "${PS1%$ORIGINAL_PS1}" > "$__ps1_new_prefix_file"
        fi
    }

    ## Add if not already there
    if ! [[ " ${precmd_functions[*]} " == *" precmd_check_for_PS1_prefix "* ]]; then
        precmd_functions+=(precmd_check_for_PS1_prefix)
    fi
fi 

prompt_indicator=()
if type -p syncthing-cwd-status >/dev/null 2>&1; then
    prompt_indicator+=("syncthing-cwd-status")
fi

if type -p git >/dev/null 2>&1; then
    parse_git_branch() {
        ref=$(git symbolic-ref HEAD 2> /dev/null) || return
        echo -en '(\033[0;32m'${ref#refs/heads/}'\033[0m)'
    }
    prompt_indicator+=("parse_git_branch")
fi



winchg() {
    local cols=${COLUMNS:-$(tput cols)}
    if [ "$cols" -lt "$OLD_COLUMNS" ]; then
        ## delete 2 lines up because the terminal probably wrapped our prompt in 2 lines
        printf "\e[s\e[A\e[A\e[G\e[K\e[u\e[J"
    fi
    printf "\e[s\e[A\e[G$(__ps1)\e[u"
    OLD_COLUMNS=$cols
}

trap 'winchg' WINCH

if [ -n "$PROMPT_COMMAND_PREV" ]; then
    PROMPT_COMMAND="${PROMPT_COMMAND_PREV}"
fi

# PROMPT_COMMAND_PREV="${PROMPT_COMMAND}"
# PROMPT_COMMAND="${PROMPT_COMMAND}; __ps1_command_started=\$(</proc/uptime)"

insert_prompt_indicator() {
    local indicator insertion
    insertion=$(for indicator in "${prompt_indicator[@]}"; do
                    out=$(eval "$indicator" 2>/dev/null) || continue
                    printf " %s" "$out"
                done)
    echo "${insertion}"
}

current_time() {
    printf "%(%Y-%m-%d %H:%M:%S)T" -1
}

__ps1:seg:pipe_status() {
    local pipestatus="$*" # $PIPESTATUS
    local all_ok=1
    [ -z "$pipestatus" ] && return

    for status in $pipestatus; do
        if [ "$status" -ne 0 ]; then
            all_ok=0
        fi
    done
    [ $all_ok -eq 1 ] && return
    echo -n "$pipestatus"

}

__ps1:seg:elapsed() {
    local stop start
    stop=$(</proc/uptime)

    [ -f "$__ps1_elapsed_start_file" ] || return

    start=$(<"$__ps1_elapsed_start_file")
    rm -f "$__ps1_elapsed_start_file"
    [ -z "$start" ] && return
    start=${start%% *}
    start=${start/./}
    stop=${stop%% *}
    stop=${stop/./}
    elapsed=$((stop - start))
    if [ $elapsed -lt 3000 ]; then
        elapsed=$(printf "%02d" "$((stop - start))")
        printf "%s" "${elapsed::-2}.${elapsed: -2}"
        return
    fi

    elapsed=$((elapsed / 100))
    print_duration "$elapsed"
}

print_duration() {
    local T=$1 fmt='%d'
    local D=$((T/60/60/24)) H=$((T/60/60%24)) M=$((T/60%60)) S=$((T%60))
    (( $D > 0 )) && {
        printf "${fmt}d" "$D"
        fmt='%2d'
    }
    (( $H > 0 )) && {
        printf "${fmt}h" "$H"
        fmt='%2d'
    }
    (( $M > 0 )) && {
        printf "${fmt}m" "$M"
        fmt='%02d'
    }
    printf "$fmt" "$S"
}

__ps1_right_segs=(
    "${csi}48;${__ps1_color_3};38;${__ps1_color_1}m:"
    "${csi}0;31m${csi}48;${__ps1_color_1}m:\$(__ps1:seg:pipe_status "\${pipestatus[@]}") "
    "${csi}0;30m${csi}48;${__ps1_color_1}m:\$(__ps1:seg:elapsed) "
    "${csi}48;${__ps1_color_1};38;${__ps1_color_2}m:"
    "${csi}0;36m${csi}48;${__ps1_color_2}m: \$(current_time) "
    "${csi}0;30m:╯"
)

__ps1:right() {
    local pipestatus=("$@")
    local csi=$'\e['
    local len=0
    local seg

    out=""
    for seg in "${__ps1_right_segs[@]}"; do
        seg=$(eval printf "\"$seg\"")
        color=${seg%%:*}
        seg=${seg#*:}
        (( len += ${#seg} ))
        out+="${color}${seg}"
    done
    echo -n "$((len - 1)):$out"
}


__ps1_left_segs=(
    "${csi}${__ps1_color[gray]}m:╭"
    "${csi}${__ps1_bg_1}m${csi}${__ps1_color[gray]}m: \$USER"
    "${csi}${__ps1_color[white]}m${csi}${__ps1_bg_1}m:@"
    "${csi}${__ps1_bg_1}m${csi}${__ps1_color[gray]}m:\$HOSTNAME "
    "${csi}48;${__ps1_color_1};38;${__ps1_color_2}m:"
    "${csi}48;${__ps1_color_1}m${csi}${__ps1_color[lblue]}m: \$(__ps1:seg:directory) "
    "${csi}48;${__ps1_color_3};38;${__ps1_color_1}m:"
)

__ps1:left() {
    local csi=$'\e['
    local len=0
    local seg

    out=""

    for seg in "${__ps1_left_segs[@]}"; do
        seg=$(eval printf "\"$seg\"")
        color=${seg%%:*}
        seg=${seg#*:}
        (( len += ${#seg} ))
        out+="${color}${seg}"
    done
    echo -n "$((len - 1)):$out"
}


unset __ps1_DIRECTORY_ALIAS
declare -A __ps1_DIRECTORY_ALIAS=(
    ["$HOME"]="~"
)

__ps1:seg:directory() {
    local pwd="$PWD" dir
    ## replace strings
    for dir in "${!__ps1_DIRECTORY_ALIAS[@]}"; do
        [[ "$pwd" != "$dir"* ]] && continue
        pwd=${pwd#$dir}
        pwd=${__ps1_DIRECTORY_ALIAS[$dir]}$pwd
        break
    done
    echo -n "$pwd"
}


__ps1() {
    local csi=$'\e['
    # local up="${csi}s"
    local eol="${csi}${COLUMNS:-$(tput cols)}C"
    # echo -n "${up}"
    ## Right part
    local right_part
    right_part=$(__ps1:right "$@")
    right_part_len=${right_part%%:*}
    right_part=${right_part#*:}

    left_part=$(__ps1:left)
    left_part_len=${left_part%%:*}
    left_part=${left_part#*:}

    cols=${COLUMNS:-$(tput cols)}
    echo -n "${left_part}${csi}1;30m${csi}38;${__ps1_color_1}m${csi}0;30m"
    local filler_size=$((cols - left_part_len - right_part_len - 2))
    for ((i = 0; i < filler_size; i++)); do
        echo -n "─"
    done
    echo -n "${eol}"
    echo -n "${csi}${right_part_len}D"
    echo -n "${right_part}"
    # echo -n "${csi}u"
    echo -n "." >> /tmp/ps1.called
    ## Left part
    # echo -n "╭${csi}1;30m$USER${csi}0;37m@${csi}1;30m$HOSTNAME${csi}0;37m]"
    # echo -n "-[${csi}1;34m$(__ps1:seg:directory)${csi}0;37m]"
    # echo -n "${right_part}"
    # echo -n "$(insert_prompt_indicator)"
    echo
}


PS1='$(__ps1 "${PIPESTATUS[@]}")\n╰ \[\e[1;37m\]\$ \[\e[0;37m\]'
ORIGINAL_PS1="$PS1"
# set-ps1() {
#     local up="\e[s"
#     local eol="\e[\${COLUMNS:-$(tput cols)}C"
    
#     PS1="${up}${eol}"
#     PS1+="\e[21D\e[0;36m⊻ \$(current_time)╯\e[u\[\033[0;37m\][\[\033[1;30m\]\u\[\033[0;37m\]@\[\033[1;30m\]\h\[\033[0;37m\]]-[\[\033[1;34m\]\w\[\033[0;37m\]]\$(insert_prompt_indicator)\$(__ps1:seg:pipe_status "\${PIPESTATUS[@]}")\n\[\033[1;37m\]\\$ \[\033[0;37m\]"
# }

# set-ps1


export PS1 PROMPT_COMMAND

unset color_prompt force_color_prompt
